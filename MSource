for(int blockTypeIndex = 0; blockTypeIndex < BlockTypeNum; ++blockTypeIndex)
{
	float randomNum = random(@P * (blockTypeIndex + 1));

	//アセットDT周り
	int AssetRefNum = point(2, "AssetRefNum", 0);
	int AssetRefIndexList[];
	for(int k = 0; k < AssetRefNum; ++k)
	{
		string assetType1 = point(1, "AssetType", blockTypeIndex);
		string assetType2 = point(2, "AssetType", k);
		if(assetType1 == assetType2)
		{
			append(AssetRefIndexList, k);
		}
	}	
	int assetRefIndex = AssetRefIndexList[int(len(AssetRefIndexList) * randomNum)];
	string assetRef = point(2, "AssetRef", assetRefIndex);
	
	//回転周り
	vector rotate = point(1, "Rotate", blockTypeIndex);
	vector assetRotate = point(2, "Rotate", assetRefIndex);
	vector axis = set(1,0,0);
	vector4 q = quaternion(radians(rotate.x + assetRotate.x) ,axis);
	matrix mRotate = qconvert(q);
	axis = set(0,1,0);
	q = quaternion(radians(rotate.y + assetRotate.y) ,axis);
	mRotate *= qconvert(q);
	axis = set(0,0,1);
	q = quaternion(radians(rotate.z + assetRotate.z) ,axis);
	mRotate *= qconvert(q);
	vector normal;
	normal.z = 1;
	q = dihedral(normal, v@N);  
	mRotate *= qconvert(q);
	normal *= mRotate; // 回転行列を乗算
	
	//移動周り    
	vector spawnBasePos = v@P;
	vector transform = point(1, "Transform", blockTypeIndex);
	transform *= adjustedScale;
	transform *= mRotate;
	spawnBasePos += transform;

	//アセットの微調整
	vector sizeRange = point(1, "SizeRange", blockTypeIndex);            
	vector assetTransform = point(2, "Transform", assetRefIndex);
	float sizeCofficient = point(2, "SizeCofficient", assetRefIndex);
	sizeCofficient *= sizeRange.x + randomNum * (sizeRange.y - sizeRange.x);
	
	int isYAxisAssetScale = point(1, "IsYAxisAssetScale", blockTypeIndex);
	vector assetScale = sizeCofficient * volumeScale.x;
	if(0 < isYAxisAssetScale) {assetScale = sizeCofficient * volumeScale.y;}
	
	vector adjustedAssetMove = assetTransform * sizeCofficient * volumeScale;
	adjustedAssetMove *= mRotate;
	spawnBasePos += adjustedAssetMove;
	
	//TransformRange
	vector transformXAxisRange = point(1 , "TransformXAxisRange", blockTypeIndex);
	vector transformYAxisRange = point(1 , "TransformYAxisRange", blockTypeIndex);

	vector spawnPos = spawnBasePos;
	spawnPos += adjustedScale.x * (i - 0.5) * widthAxis - sizeX * widthAxis / 2;
	spawnPos += adjustedScale.y * (j - 0.5) * heightAxis - sizeY * heightAxis / 2;
	
	vector movePos;
	movePos.x = random(spawnPos * 10) * (transformXAxisRange.y - transformXAxisRange.x) + transformXAxisRange.x;
	movePos.y = random(spawnPos * 20) * (transformYAxisRange.y - transformYAxisRange.y) + transformYAxisRange.y;
   
	axis = set(0,1,0);
	q = quaternion(radians(90) ,axis);
	mRotate = qconvert(q);            
	movePos *= mRotate;
	spawnPos += movePos;
	if(point(1 , "RemainRatio", blockTypeIndex) < random(spawnPos)) {continue;}
	
	int pt = addpoint(0, spawnPos);
	setpointattrib(0, "N", pt, normal);
	setpointattrib(0, "scale", pt, assetScale);
	setpointattrib(0, "AssetRef", pt, assetRef);	
}
