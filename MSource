for(int paramIndex = 0; paramIndex < point(1, "AssetParamNum", 0); ++paramIndex)
{   

	int toggleRunning = 0;
	for(int i = 0; i < len(typeNumList); i++)
	{
		int typeNum = point(1, "TypeNum", paramIndex); 
		if(typeNumList[i] == typeNum)
		{
			toggleRunning = 1;
			break;
		}       
	}
    if(toggleRunning == 0){continue;}
	
    float randomNum = random(@P * (paramIndex + 1));

    //アセットDT周り
    int AssetRefNum = point(2, "AssetRefNum", 0);
    int AssetRefIndexList[];
    for(int k = 0; k < AssetRefNum; ++k)
    {
        string assetType1 = point(1, "AssetType", paramIndex);
        string assetType2 = point(2, "AssetType", k);
        if(assetType1 == assetType2)
        {
            append(AssetRefIndexList, k);
        }
    }       
    int assetRefIndex = AssetRefIndexList[floor(int(len(AssetRefIndexList) * randomNum))];
    string assetRef = point(2, "AssetRef", assetRefIndex);
    
	
    vector4 qRotate = p@orient;
    vector spawnPos = v@P;
    vector scale = v@Scale;
    
    //-------------------------------------------------------------------------------------------------
    //AssetRef
    vector assetRotate = point(2, "Rotate", assetRefIndex);
    vector axis = set(1,0,0);
    vector4 qAssetRotate = ident();
	qAssetRotate = qmultiply(qAssetRotate, quaternion(radians(assetRotate.x) ,axis)); 
    axis = set(0,1,0);
	qAssetRotate = qmultiply(qAssetRotate, quaternion(radians(assetRotate.y) ,axis)); 
    axis = set(0,0,1);
	qAssetRotate = qmultiply(qAssetRotate, quaternion(radians(assetRotate.z) ,axis));     
    
    vector assetTransform = point(2, "Transform", assetRefIndex);
    assetTransform *= scale;
    assetTransform = qrotate(qAssetRotate, assetTransform);
    
    vector assetScale = point(2, "SizeCofficient", assetRefIndex); 
    //-------------------------------------------------------------------------------------------------
    
    //-------------------------------------------------------------------------------------------------
    //AssetParam
    vector paramRotate = point(1, "Rotate", paramIndex);
    vector axis = set(1,0,0);
    vector4 qParamRotate = ident();
	qParamRotate = qmultiply(qParamRotate, quaternion(radians(assetRotate.x) ,axis)); 
    axis = set(0,1,0);
    qParamRotate = qmultiply(qParamRotate, quaternion(radians(paramRotate.y) ,axis));
    axis = set(0,0,1);
    qParamRotate = qmultiply(qParamRotate, quaternion(radians(paramRotate.z) ,axis));
    
    vector paramTransform = point(1, "Transform", paramIndex);
    paramTransform *= scale;
    paramTransform = qrotate(qParamRotate, paramTransform);
    
    vector paramScale = point(1, "SizeCofficient", paramIndex); 
    vector sizeRange = point(1, "SizeRange", paramIndex);
    float sizeCofficient = sizeRange.x + randomNum * (sizeRange.y - sizeRange.x);
    paramScale *= sizeCofficient
    //-------------------------------------------------------------------------------------------------
    
    spawnPos += assetTransform;
    scale *= assetScale;
	qRotate = qmultiply(qRotate, qAssetRotate);
    
    spawnPos += paramTransform;
    scale *= paramScale;
	qRotate = qmultiply(qRotate, qAssetRotate);
    
    if(point(1 , "RemainRatio", paramIndex) < random(spawnPos)) {continue;}
    
    int pt = addpoint(0, spawnPos);
    setpointattrib(0, "scale", pt, assetScale);
	setpointattrib(0, "orient", pt, qRotate);
    setpointattrib(0, "unreal_instance", pt, assetRef);  
}

removepoint(0, @ptnum);
