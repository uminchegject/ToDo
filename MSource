for(int blockTypeIndex = 0; blockTypeIndex < BlockTypeNum; ++blockTypeIndex)
{
	float randomNum = random(@P * (blockTypeIndex + 1));

	//アセットDT周り
	int AssetRefNum = point(2, "AssetRefNum", 0);
	int AssetRefIndexList[];
	for(int k = 0; k < AssetRefNum; ++k)
	{
		string assetType1 = point(1, "AssetType", blockTypeIndex);
		string assetType2 = point(2, "AssetType", k);
		if(assetType1 == assetType2)
		{
			append(AssetRefIndexList, k);
		}
	}	
	int assetRefIndex = AssetRefIndexList[int(len(AssetRefIndexList) * randomNum)];
	string assetRef = point(2, "AssetRef", assetRefIndex);
	
	//回転周り
	vector rotate = 10; //point(1, "Rotate", blockTypeIndex);
	vector assetRotate = point(2, "Rotate", assetRefIndex);
	vector axis = set(1,0,0);
	vector4 q = quaternion(radians(rotate.x + assetRotate.x) ,axis);
	matrix mRotate = qconvert(q);
	axis = set(0,1,0);
	q = quaternion(radians(rotate.y + assetRotate.y) ,axis);
	mRotate *= qconvert(q);
	axis = set(0,0,1);
	q = quaternion(radians(rotate.z + assetRotate.z) ,axis);
	mRotate *= qconvert(q);
	vector normal = 0;
	normal.z = 1;
	q = dihedral(normal, v@N);  
	mRotate *= qconvert(q);
	normal *= mRotate; // 回転行列を乗算
	
	//移動周り    
	vector spawnPos = v@P;
	vector transform = (0.0, 0.0, 0.0);//point(1, "Transform", blockTypeIndex);
	transform *= adjustedScale;
	transform *= mRotate;
	spawnPos += transform;

	//アセットの微調整
	vector sizeRange = (0.8, 1.0, 0.0); //point(1, "SizeRange", blockTypeIndex);            
	vector assetTransform = point(2, "Transform", assetRefIndex);
	float sizeCofficient = point(2, "SizeCofficient", assetRefIndex);
	sizeCofficient *= sizeRange.x + randomNum * (sizeRange.y - sizeRange.x);
	
	vector scaleParam = point(1, "ScaleParam", blockTypeIndex);
	vector assetScale = sizeCofficient * v@scale;
	if(0 == scaleParam.x) {assetScale = sizeCofficient * v@scale.y;}
	if(0 == scaleParam.y) {assetScale = sizeCofficient * v@scale.x;}
	
	vector adjustedAssetMove = assetTransform * v@scale;
	adjustedAssetMove *= mRotate;
	spawnPos += adjustedAssetMove;
	
	//TransformRange
	vector transformXAxisRange = point(1 , "TransformXAxisRange", blockTypeIndex);
	vector transformYAxisRange = point(1 , "TransformYAxisRange", blockTypeIndex);
	
	vector movePos;
	movePos.x = random(spawnPos * 10) * (transformXAxisRange.y - transformXAxisRange.x) + transformXAxisRange.x;
	movePos.y = random(spawnPos * 20) * (transformYAxisRange.y - transformYAxisRange.y) + transformYAxisRange.y;
   
	axis = set(0,1,0);
	q = quaternion(radians(90) ,axis);
	mRotate = qconvert(q);            
	movePos *= mRotate;
	spawnPos += movePos;
	if(point(1 , "RemainRatio", blockTypeIndex) < random(spawnPos)) {continue;}
	
	int pt = addpoint(0, spawnPos);
	setpointattrib(0, "N", pt, normal);
	setpointattrib(0, "scale", pt, assetScale);
	setpointattrib(0, "AssetRef", pt, assetRef);	
}
