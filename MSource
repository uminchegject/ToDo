●Pattern
for(int i = 0; i < len(typeNumList); i++)
{
    int typeNum = point(1, "TypeNum", i@LoopCount); 
    if(typeNumList[i] == typeNum)
    {
        toggleRunning = 1;
        break;
    }       
}

if(toggleRunning == 1)
{
	vector blockSize = 1;
	vector patternBlockNum = 1;

	if(0.0 < patternSize.y)
	{
		patternBlockNum.y = int(floor(v@scale.y / patternSize.y));
		if(patternBlockNum.y == 0){patternBlockNum.y = 1;}
		blockSize.y = v@scale.y / patternBlockNum.y;
		v@frontDirDataList.y = -100;
	}
	else
	{
		patternBlockNum.y = 1;          
		blockSize.y = v@scale.y;
	}


	if(0.0 < patternSize.x)
	{
		patternBlockNum.x = int(floor(v@scale.x / patternSize.x));
		if(patternBlockNum.x == 0){patternBlockNum.x = 1;}
		blockSize.x = v@scale.x / patternBlockNum.x;
		v@frontDirDataList.z = -100;
	}
	else
	{
		patternBlockNum.x = 1;          
		blockSize.x = v@scale.x;
	}     

	if(0.0 < patternSize.z)
	{
		patternBlockNum.z = int(floor(v@scale.z / patternSize.x));
		if(patternBlockNum.z == 0){patternBlockNum.z = 1;}
		blockSize.z = v@scale.z / patternBlockNum.z;
		v@frontDirDataList.x = -100;
	}
	else
	{
		patternBlockNum.z = 1;          
		blockSize.z = v@scale.z;
	}
	
	//typeを追加
    int addTypeNumList[] = point(1, "AddTypeNumList", i@LoopCount);
    int index = addTypeNumList[int(floor(rand(@ptnum) * len(addTypeNumList)))];
    append(typeNumList, index);
    i[]@TypeNumList = typeNumList;
	
	//AddLoopNum
	i@LoopCount += 1;

	//removepoint
	removepoint(0, @ptnum);

	vector spawnBasePos = -v@scale / 2;
	for(int x = 0; x < patternBlockNum.x; ++x)
	{
		for(int y = 0; y < patternBlockNum.y; ++y)
		{
			for(int z = 0; z < patternBlockNum.z; ++z)
			{
				vector spawnPos = spawnBasePos;                 
				spawnPos.x += (x + 0.5) * blockSize.x;
				spawnPos.y += (y + 0.5) * blockSize.y;
				spawnPos.z += (z + 0.5) * blockSize.z;
				spawnPos *= 4@RotateMatrix;
				spawnPos += v@P;

				int pt = addpoint(0, v@P);
				setpointattrib(0, "N", pt, v@N);
				setpointattrib(0, "scale", pt, v@scale);
				setpointattrib(0, "RotateMatrix", pt, 4@RotateMatrix);
				setpointattrib(0, "FrontDirData", pt, v@FrontDirData);
				setpointattrib(0, "TypeNumList", pt, typeNumList);
				setpointattrib(0, "LoopCount", pt, i@LoopCount);
			}
		}
	}	
}


●Greeble
for(int i = 0; i < len(typeNumList); i++)
{
    int typeNum = point(1, "TypeNum", i@LoopCount); 
    if(typeNumList[i] == typeNum)
    {
        toggleRunning = 1;
        break;
    }       
}

if(toggleRunning == 1)
{

if(0 < divideLoopNum)
{
	vector dividingBlockPosList[];
	vector dividingBlockScaleList[];
	matrix dividingBlockMatrixList[];
	vector dividingBlockFrontDirDataList[];
	
	dividingBlockPosList[0] = v@P;
	dividingBlockScaleList[0] = v@scale;
	dividingBlockMatrixList[0] = 4@RotateMatrix;
	dividingBlockFrontDirDataList[0] = v@FrontDirData;
	
	float divideRatio = point(1, "DivideRatio", paramIndex);
	int divideLoopNum = point(1, "DivideLoopNum", paramIndex);
	float divideMinSize = point(1, "DivideMinSize", paramIndex);
	vector axisToDivide = point(1, "AxisToDivide", paramIndex);
	vector divideRange = point(1, "DivideRange", paramIndex);	

	vector divideAxis = 0;
	for(int j = 0; j < divideLoopNum; j++)
	{
		if(divideAxis.x == 1) 
		{
			divideAxis = 0;
			if(0 < axisToDivide.y) divideAxis.y = 1;
			else if(0 < axisToDivide.z) divideAxis.z = 1;
			else {divideAxis.x = 1;}
		}
		else if(divideAxis.y == 1) 
		{
			divideAxis = 0;
			if(0 < axisToDivide.z) divideAxis.z = 1;
			else if(0 < axisToDivide.x) divideAxis.x = 1;
			else {divideAxis.y = 1;}
		}
		else if(divideAxis.z == 1) 
		{
			divideAxis = 0;
			if(0 < axisToDivide.x) divideAxis.x = 1;
			else if(0 < axisToDivide.y) divideAxis.y = 1;
			else {divideAxis.z = 1;}
		}
	
		int dividingBlockNum = len(dividingBlockPosList);
		for(int k = 0; k < dividingBlockNum ; ++k)
		{
			loopNum += 1;
			
			vector dividingBlockPosOrigin = removeindex(dividingBlockPosList, 0);
			vector dividingBlockScaleOrigin = removeindex(dividingBlockScaleList, 0);
			matrix dividingBlockMatrixOrigin = removeindex(dividingBlockMatrixList ,0);
			vector dividingBlockFrontDirDataOrigin = removeindex(dividingBlockFrontDirDataList ,0);
			
			if(divideRatio < random()){continue;}        

			float block1ScaleValue = random(dividingBlockPosOrigin) * (divideRange.y - divideRange.x) + divideRange.x;   
			float block2ScaleValue = 1 - block1ScaleValue;
			vector block1Scale = dividingBlockScaleOrigin * (baseVector - divideAxis * block1ScaleValue);
			vector block2Scale = dividingBlockScaleOrigin * (baseVector - divideAxis * block2ScaleValue);
	
			vector block1Pos = dividingBlockPosOrigin - divideAxis * (block1Scale / 2 + dividingBlockScaleOrigin / 2 - block1Scale) * dividingBlockMatrixOrigin;
			vector block2Pos = dividingBlockPosOrigin + divideAxis * (block2Scale / 2 + dividingBlockScaleOrigin / 2 - block2Scale) * dividingBlockMatrixOrigin;
	
			//塞ぎ面周り
			vector block1CloseFront = divideAxis;
			vector block2CloseFront = -divideAxis;
			vector block1FrontDirData = dividingBlockFrontDirDataOrigin;
			vector block2FrontDirData = dividingBlockFrontDirDataOrigin; 
			int toggle = 1;
			while(toggle != 0)
			{
				if(1 < length((block1CloseFront + block1FrontDirData) * block1CloseFront)) {break;}
				block1FrontDirData += block1CloseFront + block1FrontDirData * block1CloseFront * 100;
				toggle = 0;
			}
			toggle = 1;
			while(toggle != 0)
			{
				if(1 < length((block2CloseFront + block2FrontDirData) * block2CloseFront)) {break;}
				block2FrontDirData += block2CloseFront + block2FrontDirData * block2CloseFront * 100;
				toggle = 0; 
			}
	
			if(length(divideAxis * block1Scale) < divideMinSize|| length(divideAxis * block1Scale) < divideMinSize)
			{
				push(dividingBlockPosList, dividingBlockPosOrigin);
				push(dividingBlockScaleList, dividingBlockScaleOrigin); 
				push(dividingBlockMatrixList, dividingBlockMatrixOrigin);
				push(dividingBlockFrontDirDataList, dividingBlockFrontDirDataOrigin);
				continue;           
			}
			
			push(dividingBlockPosList, block1Pos);
			push(dividingBlockPosList, block2Pos);
			push(dividingBlockScaleList, block1Scale);
			push(dividingBlockScaleList, block2Scale); 
			push(dividingBlockMatrixList, blockMatrixOrigin);
			push(dividingBlockMatrixList, blockMatrixOrigin);
			push(dividingBlockFrontDirDataList, block1FrontDirData);
			push(dividingBlockFrontDirDataList, block2FrontDirData);
		}   
	}
	
	//typeを追加
    int addTypeNumList[] = point(1, "AddTypeNumList", i@LoopCount);
    int index = addTypeNumList[int(floor(rand(@ptnum) * len(addTypeNumList)))];
    append(typeNumList, index);
    i[]@TypeNumList = typeNumList;
	
	//AddLoopNum
	i@LoopCount += 1;

	//removepoint
	removepoint(0, @ptnum);	
	
	for(int j = 0; j < len(dividingBlockPosList); j++)
	{
		push(blockPosList, dividingBlockPosList[j]);
		push(blockScaleList, dividingBlockScaleList[j]);
		push(blockMatrixList, dividingBlockMatrixList[j]);
		push(frontDirDataList, dividingBlockFrontDirDataList[j]);

		int pt = addpoint(0, dividingBlockPosList[j]);
		setpointattrib(0, "N", pt, v@N);
		setpointattrib(0, "scale", pt, dividingBlockScaleList[j]);
		setpointattrib(0, "RotateMatrix", pt, dividingBlockMatrixList[j]);
		setpointattrib(0, "FrontDirData", pt, dividingBlockFrontDirDataList[j]);
		setpointattrib(0, "TypeNumList", pt, typeNumList);
		setpointattrib(0, "LoopCount", pt, i@LoopCount);		
	}                
}
