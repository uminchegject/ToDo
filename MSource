■Volume
○Scalingを正確にする
 -分割する際にサイズを正確にするように修正

//ScaleRange
if(scaleRange.x =! 1 || scaleRange.y =! 1)
{
	float ScaleCofficient = rand(blockPosOrigin * (i + loopNum + 10)) * (scaleRange.y - scaleRange.x) + scaleRange.x;
	blockScaleOrigin *= ScaleCofficient;
	vector adjustedMoveVector = 0;
	if(abs(blockFrontDirDataOrigin.x) <= 1)
	{
		adjustedMoveVector.x = -blockFrontDirDataOrigin.x * blockScaleOrigin.x * (ScaleCofficient - 1) / 2;
	}
	if(abs(blockFrontDirDataOrigin.y) <= 1)
	{
		adjustedMoveVector.y = -blockFrontDirDataOrigin.y * blockScaleOrigin.y * (ScaleCofficient - 1) / 2;
	}
	if(abs(blockFrontDirDataOrigin.z) <= 1)
	{
		adjustedMoveVector.z = -blockFrontDirDataOrigin.z * blockScaleOrigin.z * (ScaleCofficient - 1) / 2;
	}
	adjustedMoveVector *= rotateMatrix;
{
else
{
	//移動
	vector MoveVector += transform * blockScaleOrigin;
	MoveVector *= rotateMatrix;
	blockPosOrigin += MoveVector;

	//回転周り
	float RotateValue = random(blockPosOrigin * (i + loopNum)) * (rotateRange.y - rotateRange.x) + rotateRange.x;
	vector4 q = quaternion(radians(RotateValue) ,rotateAxis);
	matrix rotateMatrix = blockMatrixOrigin * qconvert(q);

	//ボリュームスケール
	blockScaleOrigin.x *= volumeScale.x; 
	blockScaleOrigin.y *= volumeScale.y;
	blockScaleOrigin.z *= volumeScale.z;      
}

push(blockPosList, blockPosOrigin);
push(blockScaleList, blockScaleOrigin);
push(blockMatrixList, rotateMatrix);
push(frontDirDataList, blockFrontDirDataOrigin);


○NextTypeをした後そのまま継続させる
・LastTypeを設定するように修正する
if(0 < nextVolumeType) 
{         
	push(volumePosList, blockPosOrigin);
	push(volumeScaleList, blockScaleOrigin);
	push(volumeMatrixList, blockMatrixOrigin);
	push(volumeFrontDirDataList, blockFrontDirDataOrigin);
	push(volumeTypeList, nextVolumeType);
}

■Detail
○Transform周りの修正
 -Scaleの反映

○回転後の移動
 -SighBoard

vector normal = 0;
normal.z = 1;
vector4 qRotate = dihedral(normal, v@N);
matrix mRotate = qconvert(qRotate);
vector spawnPos = v@P;
vector scale = v@Scale;

//-------------------------------------------------------------------------------------------------
//AssetRef
vector assetRotate = point(2, "Rotate", assetRefIndex);
vector axis = set(1,0,0);
vector4 qAssetRotate = quaternion(radians(assetRotate.x) ,axis);
matrix mAssetRotate = qconvert(qAssetRotate);
axis = set(0,1,0);
qAssetRotate = quaternion(radians(assetRotate.y) ,axis);
mAssetRotate *= qconvert(qAssetRotate);
axis = set(0,0,1);
qAssetRotate = quaternion(radians(assetRotate.z) ,axis);
mAssetRotate *= qconvert(qAssetRotate);    

vector assetTransform = point(2, "Transform", assetRefIndex);
assetTransform *= scale;
assetTransform *= mRotate;

vector assetScale = point(2, "SizeCofficient", assetRefIndex); 
//-------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------
//AssetParam
vector paramRotate = point(1, "Rotate", blockTypeIndex);
vector axis = set(1,0,0);
vector4 qParamRotate = quaternion(radians(paramRotate.x) ,axis);
matrix mParamRotate = qconvert(qParamRotate);
axis = set(0,1,0);
qParamRotate = quaternion(radians(paramRotate.y) ,axis);
mParamRotate *= qconvert(qParamRotate);
axis = set(0,0,1);
qParamRotate = quaternion(radians(paramRotate.z) ,axis);
mParamRotate *= qconvert(qParamRotate);

vector paramTransform = point(1, "Transform", blockTypeIndex);
paramTransform *= scale;
paramTransform *= mRotate;

vector paramScale = point(1, "SizeCofficient", blockTypeIndex); 
vector sizeRange = point(1, "SizeRange", blockTypeIndex);
float sizeCofficient = sizeRange.x + randomNum * (sizeRange.y - sizeRange.x);
paramScale *= sizeCofficient
//-------------------------------------------------------------------------------------------------


○Top,Center,BottomのEdgeSizeの分離
 float top3DEdgeSideSize = point(1, "Top3DEdgeSideSize", paramIndex);
float bottom3DEdgeSideSize = point(1, "Bottom3DEdgeSideSize", paramIndex);
 
vector scale =  v@scale;
scale.x -= depthSize * 2;
scale.y -= depthSize * 2;
scale.z = topEdgeSize;
 
vector scaleTopEdge = v@scale;
scaleTopEdge.x = scale.z - top3DEdgeSideSize * 2;
scaleTopEdge.y = topEdgeSize;
scaleTopEdge.z = depthSize;

vector scale3DTopEdge = top3DEdgeSideSize;
scale3DTopEdge.y = topEdgeSize;

if(0.0 < sideEdgeSize)
if(0.0 < top3DEdgeSideSize)
if(0.0 < bottom3DEdgeSideSize)
