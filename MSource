■ToDo
・GreebleBlockで検証する

○DTParamから情報を取得しAttributeに設定する処理を実装
float Width = @SizeX;
float HDRatio = @SizeY / @SizeX;
int ParamNum = point(1, "ParamNum", 0);
int RightParamIndexes[];

for(int i = 0; i < ParamNum, ++i)
{
    vector HDRatioRange = point(1, "HDRatioRange", i);
    vector WidthRange = point(1, "WidthRange", i);
    if(HDRatioRange.x < HDRatio && HDRatio < HDRatioRange.y)
    {
       if(WidthRange.x < Width && Width < WidthRange.y)
        {
            append(RightParamIndexes, i);
        }
    }	
}	
int BlockDTIndex = RightParamIndexes[int(len(RightParamIndexes) * random(@P)];


○Attribute値を参照して処理を行うように実装
// 法線ベクトルの角度をクォタニオンに変換
vector4 qNormal = dihedral({0, 1, 0}, @N); 
matrix mNormal = qconvert(qNormal);

//移動行列の計算
vector TransformList[] = v[]@TransformList;
vector transform = TransformList[i]; 
vector pivotPos = @P;
vector nextPos = {0, 0, 0};
matrix mTrans = ident();// 単位行列を生成
translate(mTrans,transform); //開き角度から移動行列を生成

//行列を乗算
nextPos *= mTrans; // 移動行列を乗算
nextPos *= mNormal; //法線行列を計算
nextPos += pivotPos;

int ptnum = addpoint(0, nextPos);
setpointattrib(0, "N", ptnum, @N);

//スケールの計算
vector scaleList[] = v[]@ScaleList;
vector scale = scaleList[i];
scale *= set(@SizeX, @SizeX, @SizeX);  
float scaleCofficient = 0.7;
scale *= ((1 - scaleCofficient) * random(@P) + scaleCofficient);
setpointattrib(0, "scale", ptnum, scale);

//アセットパスの設定
string AssetPathsList[]= s[]@AssetPathList;
string AssetPathsStr = AssetPathsList[i];
string AssetPathList[] = split(AssetPathsStr, "!");
int UsedAssetPathIndex = int(len(AssetPathList) * random(@P));
string AssetPath = AssetPathList[UsedAssetPathIndex];
int StrStartIndex = 0;
int StrEndIndex = len(AssetPath);
setpointattrib(0, "AssetPath", ptnum, AssetPath[StrStartIndex:StrEndIndex]);
