int BlockTypeNum = point(1, "VolParamNum", 0);
for(int blockTypeIndex = 0; blockTypeIndex < BlockTypeNum; ++blockTypeIndex)
{
    //BlockType
    string selectedType = point(1, "3DBlockType", blockTypeIndex);
    string paramType = point(3, "3DBlockType", 0);
    if(selectedType != paramType) { continue;}
	
	
	//Primからサイズを取得
	int primPts[] = primpoints(0, @primnum);
	vector pt1Pos = point(0, "P", primPts[0]);
	
	float sizeX;
	float sizeY;
	vector widthAxis;
	vector heightAxis;
	
	for(int i = 1; i < primPtNum.len() ; i++)
	{
		vector ptPos = point(0, "P", primPtNum[i]);
		vector ptPosLast = point(0, "P", primPtNum[i - 1]);
		float distanceFromPt = (ptPosOrigin - ptPos);
		float distanceFromLastPt = (pt1PosOrigin - ptPosLast);
		
		if(distanceFromPt < distanceFromLastPt)
		{
			int ptNum = primPtNum[i];
			primPtNum[i] = primPtNum[i - 1];
			primPtNum[i - 1] = ptNum;	
		}		
	}
	
	vector pt1Pos = point(0, "P", primPtNum[1]);
	sizeX = length(pt1Pos - pt1PosOrigin);
	widthAxis = normalize(pt1Pos - ptPosOrigin);
	
	vector pt2Pos = point(0, "P", primPtNum[2]);
	sizeY = length(pt2Pos - pt1PosOrigin);
	heightAxis = normalize(pt2Pos - ptPosOrigin);
	
	
    //アセットDT周り
    int MaterialRefNum = point(2, "MaterialRefNum", 0);
    int MaterialRefIndexList[];
    for(int i = 0; i < MaterialRefNum; ++i)
    {
        string materialType1 = point(1, "MaterialType", blockTypeIndex);
        string materialType2 = point(2, "MaterialType", i);
        if(materialType1 == materialType2)
        {
            append(MaterialRefIndexList, i);
        }
    }
	
    float randomNum = random(@P * (blockTypeIndex + 10));
    int MaterialRefIndex = MaterialRefIndexList[int(len(MaterialRefIndexList) * randomNum)];
    string materialRef = point(2, "MaterialRef", MaterialRefIndex);
	
	
    //スケール周り
    vector scaleCofficient = point(1, "Scale", blockTypeIndex);
    sizeX *= scaleCofficient.x;
	sizeY *= scaleCofficient.y;
	
    vector blockscale = point(1, "ChildBlockScale", blockTypeIndex);
	
	
    //ブロック周り
    int blockXAxisNum = int(1 / blockscale.x);
    int blockYAxisNum = int(1 / blockscale.y);
    if(blockXAxisNum < 1) blockXAxisNum = 1;
    if(blockYAxisNum < 1) blockYAxisNum = 1;
    vector adjustedScale;
    adjustedScale.x = sizeX / blockXAxisNum;
    adjustedScale.y = sizeY / blockYAxisNum;
    adjustedScale.z = adjustedScale.x * scaleCofficient.x;
    vector volumeScale = point(1, "VolumeScale", blockTypeIndex) * adjustedScale;
	
	
    //移動周り
    vector spawnBasePos = v@P;
    vector transform = point(1, "Transform", blockTypeIndex);
    spawnBasePos += transform;
	
	
    //回転周り
    vector rotate = point(1, "Rotate", blockTypeIndex);
    vector axis = set(1,0,0);
    vector4 q = quaternion(radians(rotate.x) ,axis);
    matrix mRotate = qconvert(q);
    axis = set(0,1,0);
    q = quaternion(radians(rotate.y) ,axis);
    mRotate *= qconvert(q);
    axis = set(0,0,1);
    q = quaternion(radians(rotate.z) ,axis);
    mRotate *= qconvert(q);
    vector normal;
    normal.z = 1;
    normal *= mRotate; // 回転行列を乗算
	
	
    for(int i = 1; i < blockXAxisNum + 1; ++i)
    {
        for(int j = 1; j < blockYAxisNum + 1; ++j)
        {
			vector spawnPos = spawnBasePos;
			spawnPos += adjustedScale.x * i * widthAxis - sizeX * widthAxis;
			spawnPos += adjustedScale.y * j * heightAxis - sizeY * heightAxis;
			int pt = addpoint(0, spawnPos);
			setpointattrib(0, "N", pt, normal);
			setpointattrib(0, "scale", pt, volumeScale);
			setpointattrib(0, "MaterialRef", pt, materialRef);
        }
    }
	
}
removepoint(0, @ptnum);
