[反省]
※デバッグをしっかりする
※utf-8への文字コード設定
 -*- coding: utf-8 -*-

・新規実装をする際に新しい技術、やり方を積極的に入れていく
・既存ツールのMELを勉強する
 -頭文字が大文字のCmdsがMELで実装されている
・for分の書き方
 -range
 -enumerate
 -辞書型
 -Zip


[Study]
●HoudiniForMaya
・Tutorial
https://support.borndigital.co.jp/hc/ja/articles/900000756146--%E5%88%9D%E5%BF%83%E8%80%85%E5%90%91%E3%81%91Houdini%E3%83%88%E3%83%A9%E3%82%A4%E3%82%A2%E3%83%AB005-Houdini-Engine-for-Maya%E3%81%A7Houdini-%E3%83%87%E3%82%B8%E3%82%BF%E3%83%AB%E3%82%A2%E3%82%BB%E3%83%83%E3%83%88%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B
・Debug
https://houdinifx.jp/blog/houdini-engine-for-maya-%E3%83%87%E3%83%90%E3%83%83%E3%82%B0%E3%81%AE%E4%BB%95%E6%96%B9/


[USD]
○一度サンプルで挙動確認を行って挙動の流れを確認する

・USDの基礎
https://www.youtube.com/watch?v=4kMBwpdwkkw
https://www.slideshare.net/slideshow/usd-79288174/79288174#2
https://fereria.github.io/reincarnation_tech/usd/what_is_usd

・USDの運用
https://fereria.github.io/reincarnation_tech/usd/python/tutorials/01
https://qiita.com/ousttrue/items/b5f34e0f2441ca74467e
https://qiita.com/takahito-tejima/items/ee0332bfb5c9baed3b09

・LOPS&Soraris
https://note.com/indyzonecorp/n/ndf9d8f82d7e5#93191dbb-a31d-4dbc-851a-584b7882528b
https://houdinifx.jp/blog/lops%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF/

https://www.sidefx.com/tutorials/usd-authoring-with-solaris/
https://www.youtube.com/watch?v=SqTHglDeKtU


[Python]
■ツール課題
○GIFのマウスの移動部分を抜く

○HP側にコーディング
 -画像クリックしたら大きくなるようにする


[IZON.]
■Gimmick_06
○ChibitoのAIを復旧する
○ExcuteEverytimeを正常に動くよう修正する
○Creation周りを修正する

■Gimmick_04
○調査

■Gimmick_11
○中牟田さんに、相談する
 -サンプルを実装して、それを見せて相談する


[ProceduralModeling]
※模様を生成することを意識する
 -※模様の形態に問わずDetail部分をModelingできる方法を考える
 -※BaseParameter(Scale, Rotate, Transform)を用いた模様生成を考える

■HardSurfaceModeling
○モデリングTutorialを調べる
・ハードサーフェスモデリングについて勉強する
 -各パーツのディテール部分で応用できない場所がないかを調査する
 -プロシージャルにサポートできる行程がないかを調べる
・検証しやすいパターンを考える


■BaseParameter
・Directionを設定
・Cofficient値
・ノード形式でパラメーターを管理しつつ、編集を行っていく
 -Extrude
 -Offset(Inside, OutSide)


○Noise, Density, Directionの設定
float posCofficient = ch("PosCofficient");
float noiseCofficfient = ch("NoiseCofficfient");
float noisePlus = ch("NoisePlus");

@density = noise(v@P * posCofficient) * noiseCofficfient - noisePlus;
@noise = noise(v@P * posCofficient) * 2.2 - 1;


○方向と傾きを求める
float noiseCofficient = ch("NoiseCofficient");
float normalCofficient = ch("NormalCofficient");
vector baseDirection = ch("BaseDirection");

v@noiseVector = noise(v@P * noiseCofficient);
@noiseFloat = noise(v@P * noiseCofficient);

v@P.y += @noiseFloat;

vector direction = {0, 1, 0};
float angle = cos(baseDirection, noiseVector);
angle *= 100;
vector rotateAxis = {0, 0, 1};
direction = rotate(direction, rotateAxis, angle);

rotateAxis = {0, 1, 0};
baseDirection.y = 0;
noiseVector.y = 0;
angle = cos(baseDirection, noiseVector);
direction = rotate(direction, rotateAxis, angle);

int prim = addprim(0, "polyline");
addvertex(0, prim, @ptnum);
int pt = addpoint(0, v@P + direction);
addvertex(0, prim, pt);


○Scale
v@MinScale
v@MaxScale
・PrimのOriginPosとPrimPtsPosをベクトルにスケーリングする
 -Directionを係数にする

○Transform
v@MinTrans
v@MaxTrans
・Transを方向Matrixで回転させて移動する

○Rotate
v@MinRotate
v@MaxRotate
・軸を方向Matrixで回転させて、軸を基準に回転させる

○Extrude
v@MinExtrudeHeight
v@MaxExtrudeHeight

■Voronoi(Density)
○DensityベースでBaseParamterの検証

○Group化したPrimsの編集周りを研究

○Clusterの検証に繋げる

●PointPos
・Density
 -PosCofficientScale
 -DensityCofficientScale
 -DensityCofficientAdjustValue

●Base
・Rotate
 -Density
・Scale
 -Density
・Transform
 -Adjust

●Cluster
・フラクタル
 -ブロック化して処理をパターン化する
 -スケールコントラストに繋げる
・Layerを分けてPoint配置(数)とBaseParameterに変化を持たせる

●カラー設定
・Base, Main, Vividを意識する
 -グレースケール
 
▲境目のObj化



[ModularModelieng]
※明確なアセットセットを目標に都度新規実装を加えていく

■LineManager
・凹凸の検証
・DividePrimの検証

●TypeNumの管理
int toggleRunning = 0;
int seed = detail(0, "Seed");

//タイプに含まれているか
int typeNumList[] = i[]@TypeNumList;

for(int i = 0; i < len(typeNumList); i++)
{
    int typeNum = chi("../ParamInput/typeNum" + itoa(i@LoopCount)); 
    if(typeNumList[i] == typeNum)
    {
        removeindex(typeNumList, i);
        toggleRunning = 1;
        break;
    }
}

if(chi("../ParamInput/base_toggleBase" + itoa(i@LoopCount)) != 1)
{ 
    removepoint(0, @ptnum); 
    toggleRunning = 0;
}

if(toggleRunning == 1)
{

    //typeを追加
    string strAddTypeParam = chs("../ParamInput/addTypeNumList" + itoa(i@LoopCount));
    string strAddTypeParamBlockList[] = re_split(",", strAddTypeParam);
    foreach(string strAddTypeParamBlock; strAddTypeParamBlockList)
    {
        string strAddTypeParamList[] = re_split("_", strAddTypeParamBlock);
        int addTypeNumList[];
        foreach(string str; strAddTypeParamList)
        {
            append(addTypeNumList, atoi(str));
        }
        int type = addTypeNumList[int(floor(rand(@ptnum + seed) * len(addTypeNumList)))];
        append(typeNumList, type);
    }
    i[]@TypeNumList = typeNumList;  
}

●Frontの管理
・Sort(ByVertexOrder)で時計回りに設定する
・次のPtIndexから引いたベクトルを90度回転させた方向を内側とする


○Y軸への複製ノードの実装
//Init
float totalHeight = @Height;
float baseHeight = v@P.y;
float totalHeightRatio = 0;
for(int i = 0 ; i < i@numprim; ++i)
{
	totalHeightRatio += prim(0, "HeightRatio", i);
}
float unitHeight = totalHeight / totalHeightRatio;

//Slide
addedHeightRatio = 0;
for(int i = 0 ; i < i@numprim - 1; ++i)
{
	float heightRatio = prim(0, "HeightRatio", i);
	float heightPos = (addedHeightRatio / totalHeightRatio) * totalHeight;
	addedHeightRatio += heightRatio;	
	
	//Slide
	int primpts[] = primpoints(0, i);
	foreach(pt ; primpts)
	{

		vector ptPos = point(0, "P", pt);
		ptPos.y = baseHeight + heightPos;
		setpointattrib(0, "P", pt, ptPos);
		
		float height = heightRatio * unitHeight;
		setpointattrib(0, "Height", pt, height);		
	}	
}

//AddPrim
int primpts[] = primpoints(0, i@numprim);
float heightRatio = prim(0, "HeightRatio", i@numprim);
int prim = addprim(0, "polyline");
foreach(pt ; primpts)
{
	vector ptPos = point(0, "P", pt);
	ptPos.y = baseHeight + unitHeight * addedHeightRatio;
	pt = addpoint(0, ptPos);
	addvertex(0, prim, pt);

	float height = heightRatio * unitHeight;
	setpointattrib(0, "Height", pt, height);
}

○凹凸Arcの検証
・編集を加えた部分にTypeを新しく追加する
 -Lineを動かす
 -Edgeを動かす(内側)


○DividePrimの実装(検証)



■IDEA
●InitParameterを用いた柔軟なPDの設計
 -Scale
 -Seed

●Noise周りの設計
・NoiseParameterの追加
 -AttributeにNoiseを持たせて
 
 -Boxサイズに偏りを持たせる
 -Typeに偏りを持たせる
