[反省]
※デバッグをしっかりする
※utf-8への文字コード設定
 -*- coding: utf-8 -*-

・新規実装をする際に新しい技術、やり方を積極的に入れていく
・既存ツールのMELを勉強する
 -頭文字が大文字のCmdsがMELで実装されている
・for分の書き方
 -range
 -enumerate
 -辞書型
 -Zip


[Study]
○Houdiniのサンプルコードの確認

○DCCツールの実装フロー

・Spline曲線
https://qiita.com/khidaka/items/bce40daf5d5ea469241e



[USD]
○一度サンプルで挙動確認を行って挙動の流れを確認する

・USDの基礎
https://www.youtube.com/watch?v=4kMBwpdwkkw
https://www.slideshare.net/slideshow/usd-79288174/79288174#2
https://fereria.github.io/reincarnation_tech/usd/what_is_usd

・USDの運用
https://fereria.github.io/reincarnation_tech/usd/python/tutorials/01
https://qiita.com/ousttrue/items/b5f34e0f2441ca74467e
https://qiita.com/takahito-tejima/items/ee0332bfb5c9baed3b09

・LOPS&Soraris
https://note.com/indyzonecorp/n/ndf9d8f82d7e5#93191dbb-a31d-4dbc-851a-584b7882528b
https://houdinifx.jp/blog/lops%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF/

https://www.sidefx.com/tutorials/usd-authoring-with-solaris/
https://www.youtube.com/watch?v=SqTHglDeKtU


[Python]
■ツール課題
○GIFのマウスの移動部分を抜く

○HP側にコーディング
 -画像クリックしたら大きくなるようにする


[IZON.]
■Gimmick_06
○ChibitoのAIを復旧する
○ExcuteEverytimeを正常に動くよう修正する
○Creation周りを修正する

■Gimmick_04
○調査

■Gimmick_11
○中牟田さんに、相談する
　-サンプルを実装して、それを見せて相談する



[ProceduralModeling]
※模様を生成することを意識する
 -※模様の形態に問わずDetail部分をModelingできる方法を考える
 -※BaseParameter(Scale, Rotate, Transform)を用いた模様生成を考える

■HardSurfaceModeling
○モデリングTutorialを調べる
・ハードサーフェスモデリングについて勉強する
 -各パーツのディテール部分で応用できない場所がないかを調査する
 -プロシージャルにサポートできる行程がないかを調べる
・検証しやすいパターンを考える


■BaseParameter
・Directionを設定
・Cofficient値
・ノード形式でパラメーターを管理しつつ、編集を行っていく
 -Extrude
 -Offset(Inside, OutSide)

○Noise, Density, Directionの設定
float posCofficient = ch("PosCofficient");
float noiseCofficfient = ch("NoiseCofficfient");
float noisePlus = ch("NoisePlus");

@density = noise(v@P * posCofficient) * noiseCofficfient - noisePlus;
@noise = noise(v@P * posCofficient) * 2.2 - 1;

○方向と傾きを求める
 -Noise(vector)
float noiseCofficient = ch("NoiseCofficient");
float normalCofficient = ch("NormalCofficient");

v@noiseVector = noise(v@P * noiseCofficient);
@noiseFloat = noise(v@P * noiseCofficient);


//テスト
v@P.y += @noiseFloat;

vector normal = v@noiseVector;
normal.y = 0;
normal *= @noiseFloat * normalCofficient;

int prim = addprim(0, "polyline");
addvertex(0, prim, @ptnum);
int pt = addpoint(0, v@P + normal);
addvertex(0, prim, pt);

○Scale
v@MinScale
v@MaxScale
・PrimのOriginPosとPrimPtsPosをベクトルにスケーリングする
 -Directionを係数にする

○Transform
v@MinTrans
v@MaxTrans
・Transを方向Matrixで回転させて移動する

○Rotate
v@MinRotate
v@MaxRotate
・軸を方向Matrixで回転させて、軸を基準に回転させる

○Extrude
v@MinExtrudeHeight
v@MaxExtrudeHeight


■Voronoi(Density)
○Noiseから傾きを取得する方法を考える

○DensityベースでBaseParamterの検証

○Group化したPrimsの編集周りを研究

○Clusterの検証に繋げる

●PointPos
・Density
 -PosCofficientScale
 -DensityCofficientScale
 -DensityCofficientAdjustValue

●Base
・Rotate
 -Density
・Scale
 -Density
・Transform
 -Adjust

●Cluster
・フラクタル
 -ブロック化して処理をパターン化する
 -スケールコントラストに繋げる
・Layerを分けてPoint配置(数)とBaseParameterに変化を持たせる

●カラー設定
・Base, Main, Vividを意識する
 -グレースケール
 
▲境目のObj化




[ModularModelieng]
※明確なアセットセットを目標に都度新規実装を加えていく

■LineManager
・凹凸の検証
・DividePrimの検証

●TypeNumの管理
int toggleRunning = 0;
int seed = detail(0, "Seed");

//タイプに含まれているか
int typeNumList[] = i[]@TypeNumList;

for(int i = 0; i < len(typeNumList); i++)
{
    int typeNum = chi("../ParamInput/typeNum" + itoa(i@LoopCount)); 
    if(typeNumList[i] == typeNum)
    {
        removeindex(typeNumList, i);
        toggleRunning = 1;
        break;
    }
}

if(chi("../ParamInput/base_toggleBase" + itoa(i@LoopCount)) != 1)
{ 
    removepoint(0, @ptnum); 
    toggleRunning = 0;
}

if(toggleRunning == 1)
{

    //typeを追加
    string strAddTypeParam = chs("../ParamInput/addTypeNumList" + itoa(i@LoopCount));
    string strAddTypeParamBlockList[] = re_split(",", strAddTypeParam);
    foreach(string strAddTypeParamBlock; strAddTypeParamBlockList)
    {
        string strAddTypeParamList[] = re_split("_", strAddTypeParamBlock);
        int addTypeNumList[];
        foreach(string str; strAddTypeParamList)
        {
            append(addTypeNumList, atoi(str));
        }
        int type = addTypeNumList[int(floor(rand(@ptnum + seed) * len(addTypeNumList)))];
        append(typeNumList, type);
    }
    i[]@TypeNumList = typeNumList;  
}

●Frontの管理
・Sort(ByVertexOrder)で時計回りに設定する
・次のPtIndexから引いたベクトルを90度回転させた方向を内側とする


○Y軸への複製ノードの実装
・パラメーターの中にパラメーターを入れる
 -for分の中でLineParameter分だけfor分を回し、Lineを複製する

・Init
 -Height
 -BaseLine

・for
 -Slide
 -AddPrim
 -△Change


○凹凸Arcの検証
・編集を加えた部分にTypeを新しく追加する
 -Lineを動かす
 -Edgeを動かす(内側)


△DividePrimの実装(検証)
int makingPrimId = addprim(0, "polyline");

int primpts[] = primpoints(0, @primnum);
addvertex(0, makingPrimId, primpts[0]);
for(int i = 1; i < len(primpts); ++i)
{	
	int pts[] = primpoints(0, makingPrimId);
	if(random(point(0, "P", primpts[i])) < 0.5 && 1 < len(pts)) makingPrimId = addprim(0, "polyline");
	
	addvertex(0, makingPrimId, primpts[i]);
}
removeprim(0, @primnum, 1);


■IDEA
●InitParameterを用いた柔軟なPDの設計
 -Scale
 -Seed

●Noise周りの設計
・NoiseParameterの追加
 -AttributeにNoiseを持たせて
 
 -Boxサイズに偏りを持たせる
 -Typeに偏りを持たせる
